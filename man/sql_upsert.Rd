% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sql_upsert.R
\name{sql_upsert}
\alias{sql_upsert}
\title{SQL for upserting values}
\usage{
sql_upsert(
  data,
  table,
  con,
  conflict_target,
  update,
  insert_cols = NULL,
  returning = NULL,
  mode = "new"
)
}
\arguments{
\item{data}{A data frame or the name of a database table.}

\item{table}{The name of the database table to update, insert to, or upsert
to. Can be an unquoted character string or an identifier created with \code{\link[=ident]{ident()}}.}

\item{con}{A DBIConnection object, as returned by \code{\link[DBI:dbConnect]{DBI::dbConnect()}}.}

\item{conflict_target}{Specifies the conflict target. This can be one of
the following:
\itemize{
\item a character vector that is passed on to \code{\link[=sql_unique_cols]{sql_unique_cols()}}.
\item a constraint created with \code{\link[=sql_constraint]{sql_constraint()}} or \code{\link[=sql_unique_cols]{sql_unique_cols()}}.
}}

\item{update}{specifies the columns of \code{table} to update and its new values.
This can be one of the following:
\itemize{
\item a character vector of column names, e.g. \code{c("a", "b")} to update the
columns \code{a} and \code{b} of \code{table} with the values of the columns \code{a} and \code{b} in
\code{data}.
To update with a different column, use a named vector. For example,
\code{update = c(x = "y")} will update column \code{x} of \code{table} with column \code{y} of \code{data}.
\item a named SQL vector (generated with \code{\link[=sql]{sql()}}. In the SQL code the
database table is named \code{target} and the input data is named \code{source}.
The name specifies the column to update. For example
\code{update = sql(update_counter = "target.update_counter + 1")}
will increase the column \code{update_counter} by one.
\item a list of scalar SQL and scalar character.
}}

\item{insert_cols}{Columns from \code{data} to insert.}

\item{returning}{Specifies the columns to return. If \code{NULL} (the default)
you have to use \code{\link[DBI:dbExecute]{DBI::dbExecute()}} to execute the SQL statement.

If not \code{NULL} you have to use \code{\link[DBI:dbGetQuery]{DBI::dbGetQuery()}} to get the updated rows.
\code{returning} can be one of the following:
\itemize{
\item a (named) character vector of column names.
\item a (named) SQL vector (generated with \code{\link[=sql]{sql()}}). Note that only the
columns from \code{table} are visible, not the ones from \code{source}.
\item a list of scalar SQL and scalar character.
}

Names are used as the names of the returned columns. For example
\code{returning = list("id", time = sql("now()"))}
to return the column \code{id} and the current time in the column \code{time}.}

\item{mode}{Specify how to check for a conflict:
\itemize{
\item "new": use the SQL "ON CONFLICT" clause.
\item "old": do not use the "ON CONFLICT" clause but an anti-join.
}}
}
\description{
SQL for upserting values
}
\examples{
sql_upsert(
  data = data.frame(
    id = 1:2,
    value = c("a", "b"),
    value2 = 11:12
  ),
  table = "db_table",
  con = src_memdb2(),
  conflict_target = c("id"),
  update = list("value", updated_at = sql("now()"))
)
}
