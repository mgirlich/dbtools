new_conflict_clause <- function(conflict_target, conflict_action) {
  structure(
    list(
      conflict_target = conflict_target,
      conflict_action = conflict_action
    ),
    class = "dbtools_conflict_clause"
  )
}

#' On conflict DO NOTHING object
#'
#' @param conflict_target If `NULL` (the default) conflicts with all usable
#' constraints and unique indexes are handled. Otherwise a constraint name
#' given with `sql_constraint()` or a character vector of column names with
#' a unique index.
sql_do_nothing <- function(conflict_target = NULL) {
  new_conflict_clause(
    conflict_target,
    conflict_action = structure(
      list(),
      class = c("dbtools_conflict_do_nothing", "dbtools_conflict")
    )
  )
}

#' On conflict DO UPDATE object
#'
#' @param conflict_target A constraint name given with `sql_constraint()` or
#' a character vector of column names with a unique index.
sql_do_update <- function(conflict_target, updates) {
  if (is_empty(conflict_target)) {
    abort("conflict_target must not be empty!")
  }

  new_conflict_clause(
    conflict_target,
    conflict_action = structure(
      updates,
      class = c("dbtools_conflict_do_update", "dbtools_conflict")
    )
  )
}


#' SQL query to insert missing records
#'
#' @param conflict Conflict cause generated by `sql_do_update()` or
#' `sql_do_nothing()`
#' @param insert_cols Columns from table `from` to insert.
#'
#' @examples
#' sql_conflict_insert(
#'   table = "my_tbl",
#'   con = con,
#'   from = "my_value_table",
#'   conflict = sql_do_nothing(sql_conflict_cols("conf 1", "conf 2")),
#'   insert_cols = c("insert 1", "insert 2"),
#'   returning = list(`ret 1` = "ret_col", sql("now()"))
#' )
sql_conflict_insert <- function(from,
                                table,
                                con,
                                conflict,
                                insert_cols = NULL,
                                returning = NULL) {
  stopifnot(is.data.frame(from) || is_bare_character(from, n = 1))
  stopifnot(is_bare_character(table, n = 1))
  stopifnot(inherits(conflict, "dbtools_conflict"))
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  # stopifnot(is_sql_chr_list(returning)) --> check in sql_returning

  if (is.data.frame(from)) {
    insert_cols <- insert_cols %||% colnames(from)
    check_has_cols(from, insert_cols)

    if (is_conflict_cols(conflict)) {
      check_has_cols(from, conflict)
    }
  } else {
    if (is_null(insert_cols)) {
      abort_dbtools(
        "must provide insert_cols when table is a database table.",
        "argument"
      )
    }
  }

  from_clause <- sql_clause_from(from, con, table_name = "source", cols = insert_cols)
  conflict_clause <- to_sql(conflict, con)

  glue_sql("
    INSERT INTO {`table`} AS {`'target'`} ({`insert_cols`*})
    SELECT {`insert_cols`*}
      FROM {`from_clause`}
        ON CONFLICT {conflict_clause}",
    .con = con
  ) %>%
    sql_returning(returning, con)
}


#' SQL for inserting missing values
#'
#' @export
sql_insert_missing <- function(from,
                               table,
                               con,
                               conflict_target = NULL,
                               insert_cols = NULL,
                               returning = NULL) {
  # NOTE only rows that were succesfully inserted or updated are returned
  # see https://stackoverflow.com/questions/36083669/get-id-from-a-conditional-insert/36090746#36090746
  # --> might want to use this to return all rows

  sql_conflict_insert(
    table = table,
    con = con,
    from = from,
    conflict = sql_do_nothing(conflict_target),
    insert_cols = insert_cols,
    returning = returning
  )
}


#' SQL for inserting missing values
#'
#' @param conflict_target Name of a constraint or name of columns with a
#' unique constraint.
#'
#' @export
sql_upsert <- function(from,
                       table,
                       con,
                       updates,
                       conflict_target,
                       insert_cols = NULL,
                       returning = NULL) {
  sql_conflict_insert(
    table = table,
    con = con,
    from = from,
    conflict = sql_do_update(conflict_target, updates),
    insert_cols = insert_cols,
    returning = returning
  )
}


sql_constraint <- function(constraint) {
  if (!is_scalar_character(constraint)) {
    abort("constraint must be a scalar character.")
  }

  structure(constraint, class = "dbtools_constraint")
}

to_sql.dbtools_constraint <- function(x, con) {
  constraint <- DBI::dbQuoteIdentifier(con, x)
  paste_sql("ON CONSTRAINT ", constraint)
}

sql_conflict_cols <- function(...) {
  conflict_cols <- c(...)
  if (is_empty(conflict_cols) || !is.character(conflict_cols)) {
    abort("conflict_cols must be a non-empty character vector.")
  }

  structure(conflict_cols, class = "dbtools_conflict_cols")
}

is_conflict_cols <- function(x) {
  inherits(x, "dbtools_conflict_cols")
}

to_sql.dbtools_conflict_cols <- function(x, con) {
  conflict_cols <- DBI::dbQuoteIdentifier(con, x)
  conflict_cols_vec <- paste0(conflict_cols, collapse = ", ")
  paste_sql("(", conflict_cols_vec, ")")
}
