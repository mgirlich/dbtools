#' SQL query to insert missing records
#'
#' @param conflict Conflict cause generated by `sql_do_update()` or
#' `sql_do_nothing()`
#' @param insert_cols Columns from table `from` to insert.
#'
#' @examples
#' sql_conflict_insert(
#'   from = "my_value_table",
#'   table = "my_tbl",
#'   con = con,
#'   conflict = sql_do_nothing(sql_conflict_cols("conf 1", "conf 2")),
#'   insert_cols = c("insert 1", "insert 2"),
#'   returning = list(`ret 1` = "ret_col", sql("now()"))
#' )
sql_insert <- function(from,
                       table,
                       con,
                       conflict = NULL,
                       insert_cols = NULL,
                       returning = NULL) {
  check_standard_args(from, table, con)
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  stopifnot(is_null(conflict) || inherits(conflict, "dbtools_conflict_clause"))

  # check insert cols + conflict cols
  if (is.data.frame(from)) {
    insert_cols <- insert_cols %||% colnames(from)
    check_has_cols(from, insert_cols)

    if (is_conflict_cols(conflict$conflict_target)) {
      check_has_cols(from, conflict$conflict_target)
    }
  } else {
    if (is_null(insert_cols)) {
      abort_dbtools(
        "must provide insert_cols when table is a database table.",
        error_type = "argument"
      )
    }
  }

  from_clause <- sql_clause_from(from, con, table_name = "source", cols = insert_cols)
  if (!is_null(conflict)) {
    conflict_clause <- paste0("\nON CONFLICT ", to_sql(conflict, con))
  } else {
    conflict_clause <- NULL
  }

  glue_sql("
    INSERT INTO {`table`} AS {`'target'`} ({`insert_cols`*})
    SELECT {`insert_cols`*}
      FROM {from_clause}
    ", .con = con
  ) %>%
    paste_sql(conflict_clause) %>%
    sql_returning(returning, con)
}
