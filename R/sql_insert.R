#' SQL query to insert missing records
#'
#' @param conflict Conflict cause generated by `sql_do_update()` or
#' `sql_do_nothing()`
#' @param insert_cols Columns from table `from` to insert.
#'
#' @export
#' @examples
#' sql_conflict_insert(
#'   from = "my_value_table",
#'   table = "my_tbl",
#'   con = con,
#'   conflict = sql_do_nothing(sql_conflict_cols("conf 1", "conf 2")),
#'   insert_cols = c("insert 1", "insert 2"),
#'   returning = list(`ret 1` = "ret_col", sql("now()"))
#' )
sql_insert <- function(from,
                       table,
                       con,
                       conflict = NULL,
                       insert_cols = NULL,
                       returning = NULL,
                       return_all = FALSE) {
  check_standard_args(from, table, con)
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  stopifnot(is_null(conflict) || inherits(conflict, "dbtools_conflict_clause"))

  # check insert cols + conflict cols
  if (is.data.frame(from)) {
    insert_cols <- insert_cols %||% colnames(from)
    check_has_cols(from, insert_cols)

    if (is_conflict_cols(conflict$conflict_target)) {
      check_has_cols(from, conflict$conflict_target)
    }
  } else {
    if (is_null(insert_cols)) {
      abort_invalid_input("must provide `insert_cols` when `table` is a database table.")
    }
  }

  if (is_true(return_all) &&
      (
        is_null(returning) ||
        !is_conflict_cols(conflict$conflict_target)
      )
  ) {
    abort_invalid_input(paste0(
      "`return_all` only works with `returning` not NULL",
      " and `conflict` generated with `sql_conflict_cols()`"
    ))
  }

  from_clause <- sql_clause_from(from, con, table_name = "source", cols = insert_cols)
  if (!is_null(conflict)) {
    conflict_clause <- paste_sql("ON CONFLICT ", to_sql(conflict, con))
  } else {
    conflict_clause <- NULL
  }

  insert_sql <- sql_insert_from(
    from = "source",
    table = table,
    con = con,
    conflict = conflict,
    insert_cols = insert_cols,
    returning = returning
  )

  if (is_true(return_all)) {
    # idea from
    # https://stackoverflow.com/questions/35949877/how-to-include-excluded-rows-in-returning-from-insert-on-conflict/35953488#35953488
    # https://stackoverflow.com/questions/36083669/get-id-from-a-conditional-insert/36090746#36090746
    glue_sql("
      WITH {from_clause}
      , ins_result AS (
        {insert_sql}
      )
      SELECT *
        FROM ins_result
      UNION
      SELECT {sql_clause_select(returning, con)}
        FROM {`table`} AS {`'target'`}
       WHERE EXISTS (
         SELECT 1
           FROM source
          WHERE {sql_clause_where(conflict$conflict_target, con)}
       )
    ", .con = con)
  } else {
    glue_sql("
      WITH {from_clause}
      {insert_sql}
    ", .con = con)
  }
}


sql_insert_from <- function(from,
                            table,
                            con,
                            conflict = NULL,
                            insert_cols = NULL,
                            returning = NULL) {
  # SQLite has problems with `FROM source ON`
  # --> workaround: add `WHERE true` before
  # see https://modern-sql.com/blog/2019-01/sqlite-in-2018

  check_standard_args(from, table, con)
  stopifnot(is_bare_character(from, n = 1))
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  stopifnot(is_null(conflict) || inherits(conflict, "dbtools_conflict_clause"))

  from_clause <- sql_clause_from(from, con, table_name = "source", cols = insert_cols)

  glue_sql("
    INSERT INTO {`table`} AS {`'target'`} ({`insert_cols`*})
    SELECT {`insert_cols`*}
      FROM {from_clause}
    ", .con = con) %>%
    add_sql_conflict(conflict, con) %>%
    add_sql_returning(returning, con)
}

add_sql_conflict <- function(sql, conflict, con) {
  if (is_null(conflict)) {
    sql
  } else {
    paste_sql(sql, "\nON CONFLICT ", to_sql(conflict, con))
  }
}
