#' SQL expression list
#'
#' SQL expressions are used in the following arguments
#' * `update` (in [db_update_data()] and [db_upsert_data()])
#' * `where` (in [db_delete_data()], and [db_update_data()])
#' * `returning` (in [db_delete_data()], [db_insert_data()], [db_insert_missing_data()], [db_update_data()], and [db_upsert_data()])
#'
#' An SQL expression list is either a character vector e.g. `c("id", "name")`.
#' Or it can be a list where each element is
#' * a scalar character, i.e. a character of length 1 which must not be `NA`.
#' * a SQL class generated with [DBI::SQL()] or [glue::glue_sql()].
#'
#' A scalar character refers to a column in the dataframe and of the database
#' table. If the element is named then the name is used for the database.
#' SQL elements are not translated but left as is. In an SQL expression
#' the table to be updated is referred to as `target` and the input data
#' as `source`.
#'
#' @name sql-expression-list
NULL

#' SQL query to insert missing records
#'
#' @param data A data.frame.
#' @param table Name of the database table to insert to.
#' @param con A DBIConnection object, as returned by [DBI::dbConnect()].
#' @param conflict A conflict clause generated by [sql_do_update()] or
#' [sql_do_nothing()].
#' @param insert_cols Columns from table `data` to insert.
#' @param returning An [SQL expression list](sql-expression-list) that specifies
#' which columns to return. Names are optional and used as column names in
#' the returned table. For the default `NULL` no rows are returned.
#' @param return_all A boolean that specifies whether only newly inserted rows
#' (`FALSE`, the default) are returned or also the matching, existing rows.
#'
#' @return An SQL query.
#' @export
#' @examples
#' sql_insert(
#'   data = iris[1:2, ],
#'   table = "iris_tbl",
#'   con = con,
#'   conflict = sql_do_nothing(sql_conflict_cols("Species")),
#'   insert_cols = c("Species", "Sepal.Length", "Sepal.Width"),
#'   returning = list(`widht_plus_one` = "Sepal.Width + 1", time = SQL("now()"))
#' )
sql_insert <- function(data,
                       table,
                       con,
                       conflict = NULL,
                       insert_cols = NULL,
                       returning = NULL,
                       return_all = FALSE) {
  check_standard_args(data, table, con)
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  stopifnot(is_null(conflict) || inherits(conflict, "dbtools_conflict_clause"))

  # check insert cols + conflict cols
  if (is.data.frame(data)) {
    insert_cols <- insert_cols %||% colnames(data)
    check_has_cols(data, insert_cols)

    if (is_conflict_cols(conflict$conflict_target)) {
      check_has_cols(data, conflict$conflict_target)
    }
  } else {
    if (is_null(insert_cols)) {
      abort_invalid_input("must provide `insert_cols` when `table` is a database table.")
    }
  }

  if (is_true(return_all) &&
      (
        is_null(returning) ||
        !is_conflict_cols(conflict$conflict_target)
      )
  ) {
    abort_invalid_input(paste0(
      "`return_all` only works with `returning` not NULL",
      " and `conflict` generated with `sql_conflict_cols()`"
    ))
  }

  from_clause <- sql_clause_from(data, con, table = "source", cols = insert_cols)
  if (!is_null(conflict)) {
    conflict_clause <- paste_sql("ON CONFLICT ", to_sql(conflict, con))
  } else {
    conflict_clause <- NULL
  }

  insert_sql <- sql_insert_from(
    data = "source",
    table = table,
    con = con,
    conflict = conflict,
    insert_cols = insert_cols,
    returning = returning
  )

  if (is_true(return_all)) {
    # idea from
    # https://stackoverflow.com/questions/35949877/how-to-include-excluded-rows-in-returning-from-insert-on-conflict/35953488#35953488
    # https://stackoverflow.com/questions/36083669/get-id-from-a-conditional-insert/36090746#36090746
    glue_sql("
      WITH {from_clause}
      , ins_result AS (
        {insert_sql}
      )
      SELECT *
        FROM ins_result
      UNION
      SELECT {sql_clause_select(returning, con)}
        FROM {`table`} AS {`'target'`}
       WHERE EXISTS (
         SELECT 1
           FROM source
          WHERE {sql_clause_where(conflict$conflict_target, con)}
       )
    ", .con = con)
  } else {
    glue_sql("
      WITH {from_clause}
      {insert_sql}
    ", .con = con)
  }
}


sql_insert_from <- function(data,
                            table,
                            con,
                            conflict = NULL,
                            insert_cols = NULL,
                            returning = NULL) {
  # SQLite has problems with `FROM source ON`
  # --> workaround: add `WHERE true` before
  # see https://modern-sql.com/blog/2019-01/sqlite-in-2018

  check_standard_args(data, table, con)
  stopifnot(is_bare_character(data, n = 1))
  stopifnot(is_bare_character(insert_cols) || is_null(insert_cols))
  stopifnot(is_null(conflict) || inherits(conflict, "dbtools_conflict_clause"))

  from_clause <- sql_clause_from(data, con, table = "source", cols = insert_cols)

  glue_sql("
    INSERT INTO {`table`} AS {`'target'`} ({`insert_cols`*})
    SELECT {`insert_cols`*}
      FROM {from_clause}
    ", .con = con) %>%
    add_sql_conflict(conflict, con) %>%
    add_sql_returning(returning, con)
}

add_sql_conflict <- function(sql, conflict, con) {
  if (is_null(conflict)) {
    sql
  } else {
    paste_sql(sql, "\nON CONFLICT ", to_sql(conflict, con))
  }
}
